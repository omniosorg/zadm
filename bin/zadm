#!/usr/bin/env perl

use FindBin;
use lib qw(); # PERL5LIB
use lib "$FindBin::RealBin/../lib"; use lib "$FindBin::RealBin/../thirdparty/lib/perl5"; # LIBDIR
use strict;
use warnings;

use Pod::Usage;
use File::Basename qw(basename);
use Getopt::Long qw(:config posix_default no_ignore_case);

use Zadm::Zones;

my $VERSION = '0.dev'; # VERSION
my $PROG    = basename $0;

if ($#ARGV >= 0 && $ARGV[0] eq 'version') {
    print "$PROG $VERSION\n";
    exit 0;
}

#fix perldoc pager if not set
$ENV{PERLDOC_PAGER} ||= '/usr/bin/less -rins' if -x '/usr/bin/less';

my %delPurgeMap;

sub main {
    my $mainOpt = shift // 'list';
    my $ret = 0;

    my $zones = Zadm::Zones->new($ENV{__ZADMDEBUG} ? (loglvl => 'debug') : ());

    # check if we are in global zone
    $zones->isGZ or die "ERROR: $PROG can only be run from global zone\n";

    for ($mainOpt) {
        /^create$/ && do {
            my $zName = pop @ARGV or pod2usage(1);

            my $opts = {};
            Getopt::Long::Configure(qw(permute pass_through));
            {
                local $SIG{__WARN__} = sub { };
                GetOptions($opts, qw(brand|b=s template|t=s)) or pod2usage(1);
            }
            $opts->{brand} or pod2usage(1);

            my @extraopts = $opts->{template}
                ? (template => $zones->utils->loadTemplate($opts->{template}, $zName))
                : ();

            my $zone = $zones->zone($zName, create => 1, brand => $opts->{brand}, opts => $opts, @extraopts);

            Getopt::Long::Configure(qw(no_permute no_pass_through));
            {
                local $SIG{__WARN__} = sub { };
                GetOptions($opts, @{$zone->getOptions($mainOpt)}) or $zone->usage;
            }
            $zone->checkMandOptions($mainOpt) or $zone->usage;

            ($ret = !$zones->utils->edit($zone)) || $zone->install;

            last;
        };
        /^(?:edit|set)$/ && do {
            my $zName = $mainOpt eq 'set' ? $ARGV[-2] : $ARGV[-1] or pod2usage(1);

            my $opts = {};
            my $zone = $zones->zone($zName, opts => $opts);

            my $prop;
            if ($mainOpt eq 'set') {
                my $set = pop @ARGV or pod2usage(1);
                my ($key, $val) = split /=/, $set, 2;

                $key && $val or die "ERROR: invalid argument. Expecting 'property=value'.\n";
                $zone->isSimpleProp($key) or die "ERROR: set is only supported for simple properties.\n";

                $prop = { $key => $val };
            }

            $ret = !$zones->utils->edit($zone, $prop);

            last;
        };
        /^install$/ && do {
            my $zName = pop @ARGV or pod2usage(1);

            my $opts = {};
            Getopt::Long::Configure(qw(permute pass_through));
            {
                local $SIG{__WARN__} = sub { };
                GetOptions($opts, qw(force|f)) or pod2usage(1);
            }

            my $zone = $zones->zone($zName, opts => $opts);

            Getopt::Long::Configure(qw(no_permute no_pass_through));
            {
                local $SIG{__WARN__} = sub { };
                GetOptions($opts, @{$zone->getOptions($mainOpt)}) or $zone->usage;
            }
            $zone->checkMandOptions($mainOpt) or $zone->usage;

            die "ERROR: zone '$zName' is 'running'. Shut it down first.\n"
                if $zone->is('running');

            if (!$zone->is('configured')) {
                die "ERROR: zone '$zName' state is '" . $zone->state . "'.\n" .
                    "       Add the '-f' option to overwrite this zone.\n"
                    if !$opts->{force};

                $zone->uninstall;
            }

            # The uninstall command may have failed or been aborted by the
            # user. Only proceed with the installation if the zone is now
            # in the 'configured' state.
            $zone->install if $zone->is('configured');

            last;
        };
        /^delete$/ && do {
            my $zName = pop @ARGV or pod2usage(1);

            my $opts = {};
            {
                local $SIG{__WARN__} = sub { };
                GetOptions($opts, qw(purge=s)) or pod2usage(1);
            }
            #split all features into individual options
            if ($opts->{purge}) {
                for my $purge (split /,/, $opts->{purge}) {
                    $delPurgeMap{$purge} or die "ERROR: purge '$purge' not supported\n";
                    $opts->{$purge} = 1;
                }
                delete $opts->{purge};
            }

            my $zone = $zones->zone($zName);
            $zone->remove($opts);

            last;
        };
        /^show$/ && do {
            my $zName = shift @ARGV;
            my $prop  = shift @ARGV;

            my $config = $zones->config($zName);

            $prop && do {
                die "ERROR: attribute '$prop' not found in zone configuration.\n"
                    if !exists $config->{$prop};

                $config = $config->{$prop};
            };

            print $zones->utils->encodeJSON($config);

            last;
        };
        /^list$/ && do {
            $zones->dump;

            last;
        };
        /^list-images$/ && do {
            my $opts = {};
            {
                local $SIG{__WARN__} = sub { };
                GetOptions($opts, qw(brand|b=s provider|p=s refresh|r verbose|v)) or pod2usage(1);
            }
            $zones->image->dump($opts);

            last;
        };
        /^brands$/ && do {
            $zones->dumpBrands;

            last;
        };
        /^(?:start|boot)$/ && do {
            my $opts = {};
            Getopt::Long::Configure(qw(permute pass_through));
            {
                local $SIG{__WARN__} = sub { };
                GetOptions($opts, qw(console|c|C)) or pod2usage(1);
            }
            my $zName = pop @ARGV or pod2usage(1);

            $zones->zone($zName)->boot($opts, \@ARGV);
            last;
        };
        /^(?:stop|shutdown)$/ && do {
            my $zName = shift @ARGV or pod2usage(1);

            $zones->zone($zName)->shutdown;
            last;
        };
        /^(?:restart|reboot)$/ && do {
            my $zName = shift @ARGV or pod2usage(1);

            $zones->zone($zName)->reboot;
            last;
        };
        /^(?:poweroff|halt)$/ && do {
            my $zName = shift @ARGV or pod2usage(1);

            $zones->zone($zName)->poweroff;
            last;
        };
        /^console$/ && do {
            my $zName = pop @ARGV or pod2usage(1);

            $zones->zone($zName)->console(\@ARGV);
            last;
        };
        /^log$/ && do {
            my $zName = shift @ARGV or pod2usage(1);

            my $zone = $zones->zone($zName);
            $zone->utils->exec('pager', [ $zone->logfile ]);
            last;
        };
        /^man$/ && do {
            pod2usage(-exitstatus => 0, -verbose => 2);

            last;
        };
        /^help$/ && do {
            my $opts = {};
            {
                local $SIG{__WARN__} = sub { };
                GetOptions($opts, qw(brand|b=s)) or pod2usage(1);
            }

            pod2usage(-exitstatus => 0) if (!$opts->{brand});

            $zones->zone('global', create => 1, brand => $opts->{brand})->usage;

            last;
        };
        # not a generic command, so we forward it to the brand specific implementation
        /^\w+$/ && do {
            my $zName = pop @ARGV or pod2usage(1);

            my $zone = $zones->zone($zName);

            $zone->usage if !$zone->can($mainOpt) || !$zone->isPublic($mainOpt);

            $zone->$mainOpt(@ARGV);
            last;
        };
        #main argument invalid
        pod2usage(1);
    }
    return $ret;
}

exit main(shift);

1;

__END__

=head1 NAME

zadm - Manage OmniOS zones.

=head1 SYNOPSIS

B<zadm> I<command> [I<options...>]

where 'command' is one of the following:

    create -b <brand> [-t <template_path>] <zone_name>
    delete [--purge=vnic] <zone_name>
    edit <zone_name>
    set <zone_name> <property=value>
    install [-f] <zone_name>
    show [zone_name [property]]
    list
    list-images [--refresh] [--verbose] [-b <brand>] [-p <provider>]
    brands
    start [-c [extra_args]] <zone_name>
    stop <zone_name>
    restart <zone_name>
    poweroff <zone_name>
    console [extra_args] <zone_name>
    log <zone_name>
    help [-b <brand>]
    man
    version

=head1 DESCRIPTION

Use zadm to create/edit your zones.

=head2 B<create>

creates a zone with the name B<zone_name>. Create will open an editor
where the properties can be set. vnics which do not exist will be created.

zone properties are according to I<zonecfg>.
global properties can be set as "property" : "value" pair, single
resources as "resource" : { } hash structure and multiple resources
as "resource" : [ { }, ... ] array of hash structures.

=head2 B<delete>

deletes a zone with the name B<zone_name>.

=head2 B<edit>

modify the configuration of a zone. See the descriptions in the B<create>
function for details.

=head2 B<set>

modify the configuration of a zone. See the descriptions in the B<create>
function for details. Set only supports simple "property" : "value" pairs.

=head2 B<install>

installs a zone. Uninstalls it first if the zone is not in the configured
state if B<-f> is given.

=head2 B<show>

shows the zones' configuration. Shows config for B<zone_name>
if given.

=head2 B<list>

prints the status of all existing zones

=head2 B<list-images>

list all available images ready for download and install.

=head2 B<brands>

list all available and installed zone brands

=head2 B<start>

starts the zone B<zone_name>. Attaches to the console if B<-c> is given.
B<extra_args> will be passed to B<zlogin(1)>.

=head2 B<stop>

stops the zone B<zone_name>

=head2 B<restart>

restarts the zone B<zone_name>

=head2 B<poweroff>

forcefully stops the zone B<zone_name> (i.e. "unplug")

=head2 B<console>

attaches to the B<zone_name> zone console.
B<extra_args> will be passed to B<zlogin(1)>.

=head2 B<log>

displays the boot log for B<zone_name>

=head1 COPYRIGHT

Copyright 2020 OmniOS Community Edition (OmniOSce) Association.

=head1 LICENSE

This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option)
any later version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
more details.

You should have received a copy of the GNU General Public License along with
this program. If not, see L<http://www.gnu.org/licenses/>.

=head1 AUTHOR

S<Andy Fiddaman E<lt>omnios@citrus-it.co.ukE<gt>>
S<Dominik Hassler E<lt>hadfl@omniosce.orgE<gt>>
S<Tobias Oetiker E<lt>tobi@oetiker.chE<gt>>

=head1 HISTORY

2020-04-12 had Initial Version

=cut

